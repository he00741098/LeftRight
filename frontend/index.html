<!DOCTYPE html>
<html>

<head>
  <title>
    Left Right Sweep!
  </title>
</head>

<body>

  <div id="game">
    <div id="prompt"></div>
    <div id="indicator"></div>
    <div id="buttons">
      <div class="lrbutton" id="leftbutton"></div>
      <div class="lrbutton" id="rightbutton"></div>
    </div>

    <div class="canvascontainer" id="canvasdiv">
      <canvas id="maingame">

      </canvas>
    </div>
  </div>

  <style>
    html,
    body,
    #game {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .canvascontainer {
      width: 80%;
      height: 80%;
      position: absolute;
      left: 10%;
      top: 10%;
      margin: 0;
      padding: 0;
    }

    #maingame {}

    #game {
      display: grid;
      justify-content: center;
    }

    #indicator {
      width: 50px;
      height: 50px;
    }

    #prompt {
      width: 300px;
      height: 50px;
      font-size: 50px;
    }

    .lrbutton {
      width: 300px;
      height: 50px;
    }

    #leftbutton {}
  </style>
  <script>
    let debug_mode = true;
    const valid_pairs = [
      ["a", "d"],
      ["h", "l"],
      ["f", "j"]
    ];
    const valid_left_prompts = ["L", "l", "left", "Left", "<", "<="];
    const valid_right_prompts = ["R", "r", "right", "Right", ">", "=>"];
    const valid_sweep_prompts = ["Sweep!"];

    const prompt = document.getElementById("prompt");
    const indicator = document.getElementById("indicator");
    const canvas = document.getElementById("maingame");
    var ctx = canvas.getContext("2d");
    var animation_acceleration = 0.05;
    var animation_velocity = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];
    var animation_loop;
    var now;
    var current_pair = null;
    var current_direction = -1;
    //an array used to save the left/right/sweep order to be sent; static size so each array index will eventually be reassigned and reused.
    var directions = [-1, -1, -1, -1, -1, -1, -1, -1];
    //an array of positions of the squares so that the animations will work hopefully;
    var positions = [-1, -1, -1, -1, -1, -1, -1, -1];
    var target_positions = [-1, -1, -1, -1, -1, -1, -1, -1];
    //an index that tracks the current array index to be used
    var current_direction_index = 0;
    var shift_help_index = 0;

    function canvas_resize() {
      let rect = document.getElementById("canvasdiv").getBoundingClientRect();
      canvas.height = rect.height;
      canvas.width = rect.width;
    }
    // implement mechanics - check if a player has entered a key and send it to a centralized proccessor.
    //function that proccesses the keypress events
    let proccessor = function (event) {
      // log(event.key);
      //left right proccessor
      if (current_pair == null) {
        for (var pair of valid_pairs) {
          if (event.key == pair[0]) {
            document.dispatchEvent(new Event("left"));
            current_pair = pair;
            break;
          } else if (event.key == pair[1]) {
            document.dispatchEvent(new Event("right"));
            current_pair = pair;
            break;
          } else if (event.key == " ") {
            //space
            document.dispatchEvent(new Event("sweep"));
            break;
          } else {
            continue;
          }
        }
      } else {
        if (event.key == current_pair[0]) {
          document.dispatchEvent(new Event("left"));
        } else if (event.key == current_pair[1]) {
          document.dispatchEvent(new Event("right"));
        } else if (event.key == " ") {
          log("sweep dispatched");
          document.dispatchEvent(new Event("sweep"));
        } else {
          log("not a valid key");
        }
      }

    };
    //Initates the event listeners
    function initiate_listeners() {
      document.addEventListener("keydown", proccessor);
      window.addEventListener("resize", canvas_resize);
    }
    //function that replaces console.log--only logs when in debug mode
    function log(event) {
      if (debug_mode) {
        console.log(event);
      }
    }
    //proceed with game initialization.
    var left_func = function () {
      time_elapsed();
      if (current_direction == 0) {
        // log("Correct Left");
        trigger_correct();
      } else {
        // log("Incorrect Left");
        trigger_incorrect();
      }
      change_direction();
    };
    var right_func = function () {
      time_elapsed();
      if (current_direction == 1) {
        // log("Correct Right");
        trigger_correct();
      } else {
        // log("Incorrect Right");
        trigger_incorrect();
      }
      change_direction();
    };
    var sweep_func = function () {
      time_elapsed();
      if (current_direction == 2) {
        // log("Correct Sweep");
        trigger_correct();
      } else {
        log("Incorrect Sweep");
        trigger_incorrect();
      }
      change_direction();
    };
    function time_elapsed() {
      let new_new = performance.now();
      log("Time elapsed: " + (new_new - now) + " ms");
      now = new_new;
    }

    function trigger_correct() {
      indicator.style.backgroundColor = "green";
      shift_boxes();
    }
    function trigger_incorrect() {
      indicator.style.backgroundColor = "red";
      shift_boxes();
    }
    function initiate_game() {
      now = performance.now();
      document.addEventListener("left", (event) => {left_func()});
      document.addEventListener("right", (event) => {right_func()});
      document.addEventListener("sweep", (event) => {sweep_func()});
      generate_direction_set();
      current_direction = directions[0];
      display_switch(current_direction);
    }
    function change_direction() {
      current_direction_index++;
      if (current_direction_index > 7) {
        regenerate_direction_set(true);
        current_direction_index = 0;
      } else if (current_direction_index == 4) {
        regenerate_direction_set(false);
      }
      current_direction = directions[current_direction_index];
      display_switch(current_direction);
    }
    function display_switch(current_direction) {
      switch (current_direction) {
        case 0:
          display_left();
          break;
        case 1:
          display_right();
          break;
        case 2:
          display_sweep();
          break;
      }
    }
    function display_left() {
      current_direction = 0;
      prompt.innerText = "Left";
    }
    function display_right() {
      current_direction = 1;
      prompt.innerText = "Right";
    }
    function display_sweep() {
      current_direction = 2;
      prompt.innerText = "Sweep!";
    }

    function generate_direction_set() {
      for (var i = 0; i < directions.length; i++) {
        let random = Math.floor(Math.random() * 3);
        directions[i] = random;
      }
    }
    function regenerate_direction_set(second_half) {
      if (!second_half) {
        for (var i = 0; i < directions.length / 2; i++) {
          let random = Math.floor(Math.random() * 3);
          directions[i] = random;
        }
      } else {
        for (var i = 4; i < directions.length; i++) {
          let random = Math.floor(Math.random() * 3);
          directions[i] = random;
        }
      }
    }

    if (debug_mode) {
      // document.addEventListener("left", (event) => {log("left event")});
      // document.addEventListener("right", (event) => {log("right event")});
    }


    function draw_rectangle(x, y, direction) {
      ctx.strokeRect(x, y, Math.floor(canvas.width / 15), Math.floor(canvas.width / 15));
      ctx.font = "20px serif";
      switch (direction) {
        case 0:
          ctx.fillText("Left", Math.floor(x + canvas.width / 30) - 15, Math.floor(y + canvas.width / 30) + 6);
          break;
        case 1:
          ctx.fillText("Right", Math.floor(x + canvas.width / 30) - 20, Math.floor(y + canvas.width / 30) + 6);
          break;
        case 2:
          ctx.fillText("Sweep!", Math.floor(x + canvas.width / 30) - 28, Math.floor(y + canvas.width / 30) + 6);
          break;
      }
    }
    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    function clear_i(index) {
      ctx.clearRect((canvas.width / 2) - (canvas.width / 30) - 10, positions[index] - 10, Math.floor(canvas.width / 15) + 10, Math.floor(canvas.width / 15) + 10);
    }
    //animation targets -> target a position and move toward it
    //acceleration when player goes faster
    function animate() {
      // log("animating");
      // TODO: perbox animation velocity
      if (in_position()) {
        return;
      }
      clear();
      for (var i = 0; i < positions.length; i++) {
        if (positions[i] != target_positions[i]) {
          if (positions[i] + animation_velocity[i] > target_positions[i]) {
            positions[i] = target_positions[i];
          } else if (positions[i] + animation_velocity[i] <= target_positions[i]) {
            positions[i] += animation_velocity[i];
          }
          // draw_rectangle((canvas.width / 2) - (canvas.width / 30), positions[i], directions[i]);
          animation_velocity[i] += animation_acceleration;
        } else {
          animation_velocity[i] = 0.1;
        }
      }
      for (var i = 0; i < positions.length; i++) {
        draw_rectangle((canvas.width / 2) - (canvas.width / 30), positions[i], directions[i]);
      }
    }
    function in_position() {
      for (var i = 0; i < positions.length; i++) {
        if (positions[i] != target_positions[i]) {
          return false;
        }
      }
      return true;
    }
    function stop_animation_loop() {
      if (debug_mode) {
        clearInterval(animation_loop);
        return true;
      }
    }
    function shift_boxes() {
      // clear();
      log(shift_help_index);
      //shift box to top
      target_positions[shift_help_index] = Math.floor(canvas.height * 2 / 3) - 8 * Math.floor(canvas.width / 13);
      positions[shift_help_index] = -9 * Math.floor(canvas.width / 13);
      //TODO: prevent the boxes from overlapping
      for (var i = 0; i < positions.length; i++) {
        target_positions[i] = target_positions[i] + Math.floor(canvas.width / 13);
      }
      if (shift_help_index < 7) {
        shift_help_index += 1;
      } else {
        shift_help_index = 0;
      }
    }

    initiate_listeners();
    canvas_resize();
    for (var i = 0; i < positions.length; i++) {
      positions[i] = i * Math.floor(-canvas.width / 13) - Math.floor(canvas.width / 13);
    }
    for (var i = 0; i < positions.length; i++) {
      // target_positions[i] = 500 - i * 100;
      target_positions[i] = Math.floor(canvas.height * 2 / 3) - i * Math.floor(canvas.width / 13);
    }
    animation_loop = setInterval(animate, 1000 / 60);
    initiate_game();
  </script>
</body>

</html>
