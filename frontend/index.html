<!DOCTYPE html>
<html>

<head>
  <title>
    Left Right Sweep!
  </title>
</head>

<body>

  <div id="game">
    <div id="prompt"></div>
    <div id="indicator"></div>
    <div id="buttons">
      <div class="lrbutton" id="leftbutton"></div>
      <div class="lrbutton" id="rightbutton"></div>
    </div>

    <div class="canvascontainer" id="canvasdiv">
      <canvas id="maingame">

      </canvas>
    </div>
  </div>

  <style>
    html,
    body,
    #game {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .canvascontainer {
      width: 80%;
      height: 80%;
      position: absolute;
      left: 10%;
      top: 10%;
      margin: 0;
      padding: 0;
    }

    #maingame {}

    #game {
      display: grid;
      justify-content: center;
    }

    #indicator {
      width: 50px;
      height: 50px;
    }

    #prompt {
      width: 300px;
      height: 50px;
      font-size: 50px;
    }

    .lrbutton {
      width: 300px;
      height: 50px;
    }

    #leftbutton {}
  </style>
  <script>
    let debug_mode = true;
    const valid_pairs = [
      ["a", "d"],
      ["h", "l"],
      ["f", "j"]
    ];
    const valid_left_prompts = ["L", "l", "left", "Left", "<", "<="];
    const valid_right_prompts = ["R", "r", "right", "Right", ">", "=>"];
    const valid_sweep_prompts = ["Sweep!"];

    const prompt = document.getElementById("prompt");
    const indicator = document.getElementById("indicator");
    const canvas = document.getElementById("maingame");
    var ctx = canvas.getContext("2d");
    var velocity_base = 0.1;
    var animation_acceleration = 0.05;
    var animation_velocity = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];
    var animation_progress = [-1, -1, -1, -1, -1, -1, -1, -1];
    var animation_loop;
    var now;
    var current_pair = null;
    var current_direction = -1;
    var last_time_elapsed = [300, 300, 300, 300, 300, 300, 300, 300];
    var average_time_elapsed = () => last_time_elapsed.reduce((total, next) => total + next, 0) / last_time_elapsed.length;
    //an array used to save the left/right/sweep order to be sent; static size so each array index will eventually be reassigned and reused.
    var directions = [-1, -1, -1, -1, -1, -1, -1, -1];
    //an array of positions of the squares so that the animations will work hopefully;
    var positions = [-1, -1, -1, -1, -1, -1, -1, -1];
    var target_positions = [-1, -1, -1, -1, -1, -1, -1, -1];
    var relative_positions = [0, 0, 0, 0, 0, 0, 0, 0];
    //an index that tracks the current array index to be used
    var current_direction_index = 0;
    var shift_help_index = 0;
    //gives the relative order of the box given the index provided
    function relative_box_order(i) {
      // if shift_help_index = 0, 0 is 0
      //if shift_help_index = 1, 0 is 7, 1 is 0
      //if shift_help_index = 2, 0 is 6, 1 is 7, 2 is 0;
      let shift = i - shift_help_index;
      if (shift < 0) {
        return 8 + shift;
      } else {
        return shift;
      }
    }
    function sort_relative_positions() {
      for (var i = 0; i < positions.length; i++) {
        relative_positions[relative_box_order(i)] = i;
      }
    }

    function canvas_resize() {
      let rect = document.getElementById("canvasdiv").getBoundingClientRect();
      canvas.height = rect.height;
      canvas.width = rect.width;
    }
    // implement mechanics - check if a player has entered a key and send it to a centralized proccessor.
    //function that proccesses the keypress events
    let proccessor = function (event) {
      // log(event.key);
      //left right proccessor
      if (current_pair == null) {
        for (var pair of valid_pairs) {
          if (event.key == pair[0]) {
            document.dispatchEvent(new Event("left"));
            current_pair = pair;
            break;
          } else if (event.key == pair[1]) {
            document.dispatchEvent(new Event("right"));
            current_pair = pair;
            break;
          } else if (event.key == " ") {
            //space
            document.dispatchEvent(new Event("sweep"));
            break;
          } else {
            continue;
          }
        }
      } else {
        if (event.key == current_pair[0]) {
          document.dispatchEvent(new Event("left"));
        } else if (event.key == current_pair[1]) {
          document.dispatchEvent(new Event("right"));
        } else if (event.key == " ") {
          // log("sweep dispatched");
          document.dispatchEvent(new Event("sweep"));
        } else {
          // log("not a valid key");
        }
      }

    };
    //Initates the event listeners
    function initiate_listeners() {
      document.addEventListener("keydown", proccessor);
      window.addEventListener("resize", canvas_resize);
    }
    //function that replaces console.log--only logs when in debug mode
    function log(event) {
      if (debug_mode) {
        console.log(event);
      }
    }
    //proceed with game initialization.
    var left_func = function () {
      time_elapsed();
      if (current_direction == 0) {
        // log("Correct Left");
        trigger_correct();
        change_direction();
      } else {
        // log("Incorrect Left");
        trigger_incorrect();
      }
    };
    var right_func = function () {
      time_elapsed();
      if (current_direction == 1) {
        // log("Correct Right");
        trigger_correct();
        change_direction();
      } else {
        // log("Incorrect Right");
        trigger_incorrect();
      }
    };
    var sweep_func = function () {
      time_elapsed();
      if (current_direction == 2) {
        // log("Correct Sweep");
        trigger_correct();
        change_direction();
      } else {
        // log("Incorrect Sweep");
        trigger_incorrect();
      }
    };
    function time_elapsed() {
      let new_new = performance.now();
      log("Time elapsed: " + (new_new - now) + " ms");
      log("Avg Time elapsed : " + average_time_elapsed() + " ms");
      last_time_elapsed[shift_help_index] = new_new - now;
      now = new_new;
    }

    function trigger_correct() {
      indicator.style.backgroundColor = "green";
      shift_boxes();
    }
    function trigger_incorrect() {
      indicator.style.backgroundColor = "red";
      animation_progress[shift_help_index] = 0;
      // shift_help_index
    }
    function initiate_game() {
      now = performance.now();
      document.addEventListener("left", (event) => {left_func()});
      document.addEventListener("right", (event) => {right_func()});
      document.addEventListener("sweep", (event) => {sweep_func()});
      generate_direction_set();
      current_direction = directions[0];
      display_switch(current_direction);
    }
    function change_direction() {
      current_direction_index++;
      if (current_direction_index > 7) {
        regenerate_direction_set(true);
        current_direction_index = 0;
      } else if (current_direction_index == 4) {
        regenerate_direction_set(false);
      }
      current_direction = directions[current_direction_index];
      display_switch(current_direction);
    }
    function display_switch(current_direction) {
      switch (current_direction) {
        case 0:
          display_left();
          break;
        case 1:
          display_right();
          break;
        case 2:
          display_sweep();
          break;
      }
    }
    function display_left() {
      current_direction = 0;
      prompt.innerText = "Left";
    }
    function display_right() {
      current_direction = 1;
      prompt.innerText = "Right";
    }
    function display_sweep() {
      current_direction = 2;
      prompt.innerText = "Sweep!";
    }

    function generate_direction_set() {
      for (var i = 0; i < directions.length; i++) {
        let random = Math.floor(Math.random() * 3);
        directions[i] = random;
      }
    }
    function regenerate_direction_set(second_half) {
      if (!second_half) {
        for (var i = 0; i < directions.length / 2; i++) {
          let random = Math.floor(Math.random() * 3);
          directions[i] = random;
        }
      } else {
        for (var i = 4; i < directions.length; i++) {
          let random = Math.floor(Math.random() * 3);
          directions[i] = random;
        }
      }
    }

    if (debug_mode) {
      // document.addEventListener("left", (event) => {log("left event")});
      // document.addEventListener("right", (event) => {log("right event")});
    }


    function draw_rectangle(x, y, direction) {
      ctx.strokeRect(x, y, Math.floor(canvas.width / 15), Math.floor(canvas.width / 15));
      ctx.fillStyle = "black";
      ctx.font = "20px serif";
      switch (direction) {
        case 0:
          ctx.fillText("Left", Math.floor(x + canvas.width / 30) - 15, Math.floor(y + canvas.width / 30) + 6);
          break;
        case 1:
          ctx.fillText("Right", Math.floor(x + canvas.width / 30) - 20, Math.floor(y + canvas.width / 30) + 6);
          break;
        case 2:
          ctx.fillText("Sweep!", Math.floor(x + canvas.width / 30) - 28, Math.floor(y + canvas.width / 30) + 6);
          break;
      }
    }
    function draw_rectangle_shake(x, y, direction, ms, index) {
      // log("animating!");
      //note that with 60 fps, there is ~17 ms per frame
      //animation_progress[index]
      //ms/frame
      //max movement = 10;
      //progress goes from 0->1
      //ms / ms / frame => frame
      //frame / ms * ms = frame
      // 60 frames per second. I want the animation to last _ ms. So I need to determine how to split progress into frames
      //Knowing that 1 is 100%, then 100/ms = progress/ms
      //Then progress / ms * ms / frame = progress / frame

      let displacement = 10 * Math.sin(animation_progress[index] * Math.PI * 2);
      if (animation_progress[index] < 0) {
        animation_progress[index] = 0;
        animation_progress[index] += (1 / ms) * (1000 / 60);
      } else if (animation_progress[index] > 1) {
        animation_progress[index] = -1;
        displacement = 0;
      } else {
        animation_progress[index] += (1 / ms) * (1000 / 60);
      }
      // log(animation_progress);
      ctx.fillStyle = "red";
      ctx.strokeRect(x + displacement, y, Math.floor(canvas.width / 15), Math.floor(canvas.width / 15));
      ctx.font = "20px serif";
      switch (direction) {
        case 0:
          ctx.fillText("Left", Math.floor(x + canvas.width / 30) - 15 + displacement, Math.floor(y + canvas.width / 30) + 6);
          break;
        case 1:
          ctx.fillText("Right", Math.floor(x + canvas.width / 30) - 20 + displacement, Math.floor(y + canvas.width / 30) + 6);
          break;
        case 2:
          ctx.fillText("Sweep!", Math.floor(x + canvas.width / 30) - 28 + displacement, Math.floor(y + canvas.width / 30) + 6);
          break;
      }

    }
    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    function semi_clear() {
      ctx.fillStyle = "rgb(255 255 255 / 70%)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    function clear_i(index) {
      ctx.clearRect((canvas.width / 2) - (canvas.width / 30) - 10, positions[index] - 10, Math.floor(canvas.width / 15) + 10, Math.floor(canvas.width / 15) + 10);
    }
    //animation targets -> target a position and move toward it
    //acceleration when player goes faster
    function animate() {
      // log("animating");
      if (in_position()) {
        clear();
        draw_all();
        return;
      }
      semi_clear();
      sort_relative_positions();
      if (average_time_elapsed() < 100) {
        log("reached 250 avg");
        // no more animation...
        clear();
        for (var i of relative_positions) {
          positions[i] = target_positions[i];
        }
        draw_all();
        return;
        // velocity_base = 800;
      } else if (average_time_elapsed() < 340) {
        log("reached 270 ms avg");
        for (var i = 0; i < animation_velocity.length; i++) {
          //100 ms is 100%, 340 ms is 0%
          // 100 / 100 = 1 340 / 100 = 3.4
          animation_velocity[i] = 10 * (1 / (average_time_elapsed() / 100)) + 1;
        }
      } else if (average_time_elapsed() < 340) {
        log("reached 340 ms avg");
        for (var i = 0; i < animation_velocity.length; i++) {
          animation_velocity[i] = 3;
        }
      }
      else if (average_time_elapsed() > 600) {
        velocity_base = 0.1;
      }
      //TODO: prevent box overlap and collision
      // Make sure that the difference in positions between adjacent boxes does not go below a certain number
      let last_position = 10000;
      for (var i of relative_positions) {
        if (positions[i] != target_positions[i]) {
          if (positions[i] + animation_velocity[i] * (7 - (relative_box_order(i))) > last_position - Math.floor(canvas.width / 13)) {

            if (last_position < 50) {
              //off screen in initial position
              // log("triggering");
              //do nothing
              // positions[i] = -9 * Math.floor(canvas.width / 13);
            } else {
              //do nothing...
              positions[i] = last_position - Math.floor(canvas.width / 13);
            }

          } else if (positions[i] + animation_velocity[i] * (7 - (relative_box_order(i))) > target_positions[i]) {
            positions[i] = target_positions[i];
          } else if (positions[i] + animation_velocity[i] * (7 - (relative_box_order(i))) <= target_positions[i]) {
            positions[i] += animation_velocity[i] * (7 - (relative_box_order(i)));
          }
          // draw_rectangle((canvas.width / 2) - (canvas.width / 30), positions[i], directions[i]);
          animation_velocity[i] += animation_acceleration;
        } else {
          animation_velocity[i] = velocity_base;
        }
        if (positions[i] < -9 * Math.floor(canvas.width / 13)) {
          last_position = -9 * Math.floor(canvas.width / 13);
        } else {
          last_position = positions[i];
        }
      }
      draw_all();
    }

    function draw_all() {
      for (var i of relative_positions.toReversed()) {
        if (animation_progress[i] < 0) {
          draw_rectangle((canvas.width / 2) - (canvas.width / 30), positions[i], directions[i]);
        } else {
          draw_rectangle_shake((canvas.width / 2) - (canvas.width / 30), positions[i], directions[i], 500, i);
        }

      }
    }
    function in_position() {
      for (var i = 0; i < positions.length; i++) {
        if (positions[i] != target_positions[i]) {
          return false;
        }
      }
      return true;
    }
    function stop_animation_loop() {
      if (debug_mode) {
        clearInterval(animation_loop);
        return true;
      }
    }
    function shift_boxes() {
      // clear();
      // log(shift_help_index);
      //shift box to top
      target_positions[shift_help_index] = Math.floor(canvas.height * 2 / 3) - 8 * Math.floor(canvas.width / 13);
      positions[shift_help_index] = -9 * Math.floor(canvas.width / 13);
      animation_velocity[shift_help_index] = 1;
      //TODO: prevent the boxes from overlapping
      for (var i = 0; i < positions.length; i++) {
        target_positions[i] = target_positions[i] + Math.floor(canvas.width / 13);
      }
      if (shift_help_index < 7) {
        shift_help_index += 1;
      } else {
        shift_help_index = 0;
      }
    }

    initiate_listeners();
    canvas_resize();
    for (var i = 0; i < positions.length; i++) {
      positions[i] = i * Math.floor(-canvas.width / 13) - Math.floor(canvas.width / 13);
    }
    for (var i = 0; i < positions.length; i++) {
      // target_positions[i] = 500 - i * 100;
      target_positions[i] = Math.floor(canvas.height * 2 / 3) - i * Math.floor(canvas.width / 13);
    }
    animation_loop = setInterval(animate, 1000 / 60);
    initiate_game();
  </script>
</body>

</html>
